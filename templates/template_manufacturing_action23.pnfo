// Action2/3-chain for cargo processing at secondary industries
// Currently designed for secondary industries with three independent inputs, two outputs, no production boost
// May be able to template for number of input/output cargos

// How to use:
// Add to the top of a primary industry a few #define lines. For example:
//#define THIS_INDUSTRY                 IND_TEXTILE_MILL
//#define THIS_NUM_INPUT_CARGOS         \d02      // range 01-02  // do not include prod boost cargo
//#define THIS_NUM_OUTPUT_CARGOS        \d02      // range 01-02
//#define THIS_PROD_RATIO_CARGO_IN_2    \d01      // do not set to 0 - used for division
//#define THIS_PROD_RATIO_CARGO_IN_3    \d01      // do not set to 0 - used for division  // !! remove when code cleaned
//#define THIS_STR_INFO_CB38            STR_INFO_GENERIC
//#define THIS_STR_BOOST        STR_INFO_MS_PRIMARY_BOOST
//#define THIS_STR_ACCEPT       \wxD4D0
//#define THIS_STR_NOT_ACCEPT   \wxD4D1

// then add as the 2nd last line, prior to the end of the climate availability label
// #include "../../templates/template_secondary_action23_A.pnfo"

// In principle you can also add the defines immediately above this #define line...


// Local defines - to improve readability
#define LOCAL_CARGO_1_CONSUMED_STORE    07
#define LOCAL_CARGO_2_CONSUMED_STORE    08
#define LOCAL_CARGO_3_CONSUMED_STORE    09
#define LOCAL_CARGO_1_CONSUMED_STORE_DWORD    \dx07
#define LOCAL_CARGO_2_CONSUMED_STORE_DWORD    \dx08
#define LOCAL_CARGO_3_CONSUMED_STORE_DWORD    \dx09

#define LOCAL_CARGO_1_PRODUCED_STORE   0A
#define LOCAL_CARGO_2_PRODUCED_STORE   0B
#define LOCAL_CARGO_1_PRODUCED_STORE_DWORD   \dx0A
#define LOCAL_CARGO_2_PRODUCED_STORE_DWORD   \dx0B

// Preferred action 2 ID ranges, to keep life simple...
//   production code	00-0F, A0-AF
//   cargo acceptance	B0-BF
//   misc branching, handle callbacks etc	C0-CF
//   monthly / random production change	D0-DF
//   texts	E0-FF
//   generally unused and available	10-9F

//3 input cargos
//2 output cargos
//1:1 production ratio input:output 
//50:50 distribution to output cargos C1 output = 50% total input, C1 output = 50% total input

// !! there may be flawed logic here; if production ratio is < 8, I think too much / not enough input cargo may be used.  Needs checking.

// production code 
//!! case of 0 output cargo? - probably a different template...
-1 * 0 02 0A 00 //production cb, 1 output cargo 
	01 //version
	LOCAL_CARGO_1_CONSUMED_STORE  LOCAL_CARGO_2_CONSUMED_STORE  LOCAL_CARGO_3_CONSUMED_STORE //<subtract-in-1..3>
	LOCAL_CARGO_1_PRODUCED_STORE  LOCAL_CARGO_2_PRODUCED_STORE //<add-out-1..2>
	00 //don't repeat

-1 * 0 02 0A AC //where one cargo produced, all of production goes in register 0A, register 0B is zeroed
    89 // 
      1A 20 \dx00 // create 0
      10 1A 20 LOCAL_CARGO_2_PRODUCED_STORE_DWORD //store in persistent storage (for debug only, can be commented if not in use)
      \2sto 1A 20 LOCAL_CARGO_2_PRODUCED_STORE_DWORD //store in register
      0F
      7D 0C 20  \dxFFFFFFFF //get stored amount for total cargo output
      10 1A 20 LOCAL_CARGO_1_PRODUCED_STORE_DWORD //store in persistent storage (for debug only, can be commented if not in use)
      \2sto 1A 00 LOCAL_CARGO_1_PRODUCED_STORE_DWORD //store in register
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       00 00  00 00 00 00  00 00 00 00
     00 00 //default

-1 * 0 02 0A AB //where two cargos produced, industry output is split 50:50
    89 // 
      7D 0C 20  \dxFFFFFFFF //get stored amount for total cargo output
      \2/ 1A 20 THIS_NUM_OUTPUT_CARGOS
      10 1A 20 LOCAL_CARGO_2_PRODUCED_STORE_DWORD //store in persistent storage (for debug only, can be commented if not in use)
      \2sto 1A 20 LOCAL_CARGO_2_PRODUCED_STORE_DWORD //store in register
      10 1A 20 LOCAL_CARGO_1_PRODUCED_STORE_DWORD //store in persistent storage (for debug only, can be commented if not in use)
      \2sto 1A 00 LOCAL_CARGO_1_PRODUCED_STORE_DWORD //store in register
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       00 00  00 00 00 00  00 00 00 00
     00 00 //default

-1 * 0 02 0A AA //how many output cargos do we have?  branch accordingly (branching easier than advanced varaction 2 here)
    89 // 
      1A 00 THIS_NUM_OUTPUT_CARGOS 
    \b1 //range
       AB 00  \d02  \d02
     AC 00 //default

-1 * 0 02 0A A9 //add up total cargo produced...
    89 // 
      7C 04 20  \dxFFFFFFFF //get stored amount for production from cargo 2
      \2+ 7C 05 20  \dxFFFFFFFF //get stored amount for production from cargo 3
      10 1A 20 \dx0C //store in persistent storage (for debug only, can be commented if not in use)
      \2sto 1A 00 \dx0C //store in register
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       AA 00  00 00 00 00  00 00 00 00
     AA 00 //default

-1 * 0 02 0A A8 //calculate amount of input cargo 3 actually processed
    89 // 
      7C 05 20  \dxFFFFFFFF //get stored amount for production from cargo 3
      \2* 1A 20 \d08 // multiply result by 8
      \2/ 7C 02 20  \dxFFFFFFFF //divide production amount by production ratio 
      \2> 1A 20 \d03 // take greater value of result | 03 to handle case where result < 1 and cargo doesn't clear (3 is arbitrary, seems about right)
      10 1A 20 LOCAL_CARGO_3_CONSUMED_STORE_DWORD //store in persistent storage (for debug only, can be commented if not in use)
      \2sto 1A 00 LOCAL_CARGO_3_CONSUMED_STORE_DWORD //store in register
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A9 00  00 00 00 00  00 00 00 00
     A9 00 //default

-1 * 0 02 0A A7 //calculate amount of input cargo 2 actually processed
    89 // 
      7C 04 20  \dxFFFFFFFF //get stored amount for production from cargo 2
      \2* 1A 20 \d08 // multiply result by 8
      \2/ 7C 01 20  \dxFFFFFFFF //divide production amount by production ratio 
      \2> 1A 20 \d03 // take greater value of result | 03 to handle case where result < 1 and cargo doesn't clear (3 is arbitrary, seems about right)
      10 1A 20 LOCAL_CARGO_2_CONSUMED_STORE_DWORD //store in persistent storage (for debug only, can be commented if not in use)
      \2sto 1A 00 LOCAL_CARGO_2_CONSUMED_STORE_DWORD //store in register
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A8 00  00 00 00 00  00 00 00 00
     A8 00 //default

-1 * 0 02 0A A6 //store lower value of: (cargo waiting divided by prod ratio for cargo) or (output limit for produced cargo) 
    89 // 
      42 20  \dxFFFFFFFF // cargo 3 waiting  
      \2* 7C 02 20  \dxFFFFFFFF //multiply cargo waiting by production ratio to get calculated production value
      \2/ 1A 20  \d08 //divide result by 8
      \2< 7C 00 20  \dxFFFFFFFF //result = min(calculated production value, output limit for produced cargo)
      10 1A 00 \dx05 //store in persistent storage (could use ordinary register, but this is easier to debug)
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A7 00  00 00 00 00  00 00 00 00
     A7 00 //default

-1 * 0 02 0A A5 //store lower value of: (cargo waiting divided by prod ratio for cargo) or (output limit for produced cargo) 
    89 // 
      41 20  \dxFFFFFFFF // cargo 2 waiting 
      \2* 7C 01 20  \dxFFFFFFFF //divide cargo waiting by production ratio to get calculated production value 
      \2/ 1A 20  \d08 //divide cargo waiting by 8
      \2< 7C 00 20  \dxFFFFFFFF //result = min(calculated production value, output limit for produced cargo)
      10 1A 00 \dx04 //store in persistent storage (could use ordinary register, but this is easier to debug)
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A6 00  00 00 00 00  00 00 00 00
     A6 00 //default
// ^^ would be more correct to branch for case where no cargo waiting, or cargo waiting < 8.  
// There is a bit of a hack for case when low cargo amounts are present


// case NO production boost waiting   
-1 * 0 02 0A A4 //store production ratios for cargo 3
    89 // using type 89 because register IDs are better specified as double words
      1A 20  THIS_PROD_RATIO_CARGO_IN_3 //production ratio (number of units output per 8 units input)   
      10  1A 00 \dx02 //store in persistent storage (could use ordinary register, but this is easier to debug)
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A5 00  00 00 00 00  00 00 00 00
     A5 00
       
-1 * 0 02 0A A3 //store production ratios for cargo 2
    89 // using type 89 because register IDs are better specified as double words
      1A 20  THIS_PROD_RATIO_CARGO_IN_2 //production ratio (number of units output per 8 units input)
      10  1A 00 \dx01 // store in persistent storage
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A4 00  00 00 00 00  00 00 00 00
     A4 00

-1 * 0 02 0A C4 //consume 0t of production boost cargo
    89 // 
      1A 20 \d00 // create 0
      10 1A 20 LOCAL_CARGO_1_CONSUMED_STORE_DWORD //store in persistent storage (for debug only, can be commented if not in use)
      \2sto 1A 20 LOCAL_CARGO_1_CONSUMED_STORE_DWORD //store in register
      0F // see next line
      1A 00 \d01 // create 01 to suppress renum warning that default value can't be reached by this varaction 2
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A3 00  00 00 00 00  00 00 00 00
     A3 00 //default
     
// case SOME production boost waiting 
-1 * 0 02 0A A2 //store production ratios for cargo 3 if production boost available
    89 // using type 89 because register IDs are better specified as double words
      1A 20  \d08 //production ratio (number of units output per 8 units input)
      10  1A 00 \dx02 //store in persistent storage (could use ordinary register, but this is easier to debug)
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A5 00  00 00 00 00  00 00 00 00
     A5 00
       
-1 * 0 02 0A A1 //store production ratios for cargo 2 if production boost available
    89 // using type 89 because register IDs are better specified as double words
      1A 20  \d08 //production ratio (number of units output per 8 units input)
      10  1A 00 \dx01 // store in persistent storage
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       A2 00  00 00 00 00  00 00 00 00
     A2 00
     
 -1 * 0 02 0A C3 //consume 50t of production boost cargo if some waiting
89 // 
  1A 20 \d50 // create 50
  10 1A 20 LOCAL_CARGO_1_CONSUMED_STORE_DWORD //store in persistent storage (for debug only, can be commented if not in use)
  \2sto 1A 00 LOCAL_CARGO_1_CONSUMED_STORE_DWORD //store in register
\b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
   A1 00  00 00 00 00  00 00 00 00
 A1 00 //default

// branch depending on production boost cargo
-1 * 0 02 0A C2 //check production boost cargo waiting 
  85 40 00 FF FF //check cargo waiting
  \b1 //range
    C3 00  01 00  FF FF //there is some cargo 
  C4 00

// !! the logic for output limit is flawed.  This assumes limit is FF FF; when 2 output cargos are split 50:50, output limit before split is 2 * FF FF
// TTDPatch wiki for production callback: "results are clamped to the allowed range (0..32767 for incoming cargo amounts, 0..65535 for outgoing cargo amounts)."
-1 * 0 02 0A C1 //store output limit for produced cargo (as units of output cargo) to use when processing each input cargo
    89 // using type 89 because register IDs are better specified as double words
      1A 20  \dxFFFF // create a value (constant 1A); total production limit is FF FF per output cargo
      \2/ 1a 20 THIS_NUM_INPUT_CARGOS // divide by number of input cargos for this industry (exclude production-boosting cargos from input cargo count)
      10  1A 00 \dx00 // store in persistent storage
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       C2 00  00 00 00 00  00 00 00 00
     C2 00


// industry window cargo sub texts
// production boost cargo - branching chain based on number of input cargos defined 
// value for THIS_NUM_INPUT_CARGOS should not include prod boost cargo 
-1 * 0 02 0A E0//handle cb 37 cargo subtexts (used here to provide max cargo limit information)
  81 18 00 FF 
  \b1
    STR_INFO_LIMIT_800 80 00 00 // prod boost subtext for second cargo
  FF FF	 //default

// Set the actual limit in the following action2 by means of this action6
-1 * 0 06 LIMIT_MANUFACTURING_SUPPLIES \b02 \b11 FF

// handle cargo acceptance - production boost cargo
-1 * 0 02 0A B0//return cargo acceptance (0 or 1) depending on amount of first cargo waiting
  85 40 00 FF FF
  \b1 //range 
    00 80 01 00 FF FF 
  01 80

  
// PROVIDE DEBUG INFO TO INDUSTRY WINDOW 
//Remember text stack is LIFO (like array.pop) - put values to render first in highest registers
-1 * 0 02 0A FE //store one values to text stack for debugging
    89 // 
      7c 00 20 \dxffffffff
      \2sto 1a 00 \dx104
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       STR_INFO_DEBUG_2 80  00 00 00 00  00 00 00 00
     STR_INFO_DEBUG_2 80 //default

-1 * 0 02 0A FD //store one values to text stack for debugging
    89 // 
      7c LOCAL_CARGO_1_CONSUMED_STORE 20 \dxffffffff
      \2sto 1a 00 \dx103
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       FE 00  00 00 00 00  00 00 00 00
     FE 00 //default


-1 * 0 02 0A FC //store two values to text stack for debugging
    89 // 
      7c LOCAL_CARGO_2_PRODUCED_STORE 20 \dxffff
      \2ror 1a 20 \d16
      \2| 7c LOCAL_CARGO_1_PRODUCED_STORE 20 \dxffff
      \2sto 1a 00 \dx102
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       FD 00  00 00 00 00  00 00 00 00
     FD 00 //default
     
-1 * 0 02 0A FB //store two values to text stack for debugging
    89 // 
      7c LOCAL_CARGO_3_CONSUMED_STORE 20 \dxffff
      \2ror 1a 20 \d16
      \2| 7c LOCAL_CARGO_2_CONSUMED_STORE 20 \dxffff
      \2sto 1a 00 \dx101
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       FC 00  00 00 00 00  00 00 00 00
     FC 00 //default

-1 * 0 02 0A FA //store two values to text stack for debugging
    89
      7c 02 20 \dxffff    // storage 01 holds prod ratio cargo 2
      \2ror 1a 20 \d16
      \2| 7c 01 20 \dxffff  // storage 02 holds = prod ratio cargo 1
      \2sto 1a 00 \dx100
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       FB 00  00 00 00 00  00 00 00 00
     FB 00 //default


-1 * 0 02 0A F3 //store sub-text ID to register, return text ID  
    85 // 
      1A 20 THIS_STR_ACCEPT //create a value (constant 1A anded (20) with following bytes) 
      0E 1A 00 \wx100 //store in register
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       THIS_STR_BOOST 80 00 00 00 00
     THIS_STR_BOOST 80 //default
     
-1 * 0 02 0A F2 //store sub-text ID to register, return text ID  
    85 // 
      1A 20 THIS_STR_NOT_ACCEPT //create a value (constant 1A anded (20) with following bytes) 
      0E 1A 00 \wx100 //store in register
    \b1 //range (stay out of the nvar=0 bear pit by checking one range, but returning same for both)
       THIS_STR_BOOST 80 00 00 00 00
     THIS_STR_BOOST 80 //default
      
// Set the actual limit in the following action2 by means of this action6
-1 * 0 06 LIMIT_MANUFACTURING_SUPPLIES \b02 \b11 FF

-1 * 0 02 0A F1 //branch depending on cargo waiting (we want different text to show in industry window) 
  85 40 00 FF FF //check cargo waiting
  \b1 //range
    F2 00  01 00  FF FF    
  F3 00 //default	

-1 * 0 02 0A F0 //
    81 // 
      7F DEBUG_PARAMETER 00 DEBUG_PARAMETER_INDUSTRY_TEXT_BIT // check if first bit is set for debug parameter
    \b1 //range
       FA 00  DEBUG_PARAMETER_INDUSTRY_TEXT_BIT  DEBUG_PARAMETER_INDUSTRY_TEXT_BIT
     F1 00 //default

// handle callbacks
-1 * 0 02 0A C0 //-1 * 0 0A <set-id>
	85 0C //<type> <variable> word-access callback
	00 FF FF //no shift, no mask
	\b4 //number of ranges to check
	  THIS_STR_INFO_CB38 80   38 00   38 00 ////cb 38 display additional text in fund window
	  E0 00   37 00   37 00 //cargo subtext industry window cb 37
	  F0 00   3A 00   3A 00 //cb 3A (industry window)
	  B0 00   3D 00   3D 00 //industry cargo acceptance
	C1 00 //default

// industry action 3 attach varaction2 chain to industry
-1 * 0 03 0A 01 THIS_INDUSTRY 00 \wxC0 //-1 * 0 03 09 <n-ids> <id> 00 <def-cid>	

#undef LOCAL_CARGO_1_CONSUMED_STORE
#undef LOCAL_CARGO_2_CONSUMED_STORE
#undef LOCAL_CARGO_3_CONSUMED_STORE
#undef LOCAL_CARGO_1_CONSUMED_STORE_DWORD
#undef LOCAL_CARGO_2_CONSUMED_STORE_DWORD
#undef LOCAL_CARGO_3_CONSUMED_STORE_DWORD

#undef LOCAL_CARGO_1_PRODUCED_STORE
#undef LOCAL_CARGO_2_PRODUCED_STORE
#undef LOCAL_CARGO_1_PRODUCED_STORE_DWORD
#undef LOCAL_CARGO_2_PRODUCED_STORE_DWORD

#undef THIS_INDUSTRY
#undef THIS_STR_INFO_CB38
#undef THIS_NUM_INPUT_CARGOS
#undef THIS_NUM_OUTPUT_CARGOS
#undef THIS_PROD_BOOST_CARGO 
#undef THIS_PROD_RATIO_CARGO_IN_2
#undef THIS_PROD_RATIO_CARGO_IN_3

#undef THIS_STR_BOOST
#undef THIS_STR_ACCEPT
#undef THIS_STR_NOT_ACCEPT

