/*
 * This file is part of FIRS Industry Set for OpenTTD.
 * FIRS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
 * FIRS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with FIRS. If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * The opening behaviour of industries opened randomly by the game
 * can be controlled by a NewGRF parameter
 */
#define CHECK_OPENING(switchname, minyear, maxyear) \
switch(FEAT_INDUSTRIES, SELF, switchname ## _year_check, (current_date + 1)) { \
	date(minyear, 1, 1) .. date(maxyear, 1, 1): return CB_RESULT_IND_ALLOW; \
	return CB_RESULT_IND_DISALLOW; \
} \
 \
switch(FEAT_INDUSTRIES, SELF, switchname ## _founder_check, (extra_callback_info2 & 255)) { \
	1: return CB_RESULT_IND_DISALLOW; \
	2: return CB_RESULT_IND_DISALLOW; \
	switchname ## _year_check; \
} \
 \
switch(FEAT_INDUSTRIES, SELF, switchname, restrict_open_during_gameplay) { \
	1..255: switchname ## _founder_check; \
	switchname ## _year_check; \
}


/*
 * The closure behaviour of secondary industries
 * can be controlled by a NewGRF parameter
 */
#define CHECK_CLOSE_SECONDARY(switchname) \
switch(FEAT_INDUSTRIES, SELF, switchname ## _founder, (extra_callback_info2 & 1)) { \
	0: return CB_RESULT_IND_PROD_CLOSE; \
	return CB_RESULT_IND_PROD_NO_CHANGE; \
} \
switch(FEAT_INDUSTRIES, SELF, switchname ## _had_produced_check, LOAD_PERM(15)) { \
	0..18: return CB_RESULT_IND_PROD_NO_CHANGE; \
	switchname ## _founder; \
} \
switch(FEAT_INDUSTRIES, SELF, switchname, allow_close_secondary) { \
	1..255: switchname ## _had_produced_check; \
	return CB_RESULT_IND_PROD_NO_CHANGE; \
}

/*
 * Template which maps the random colour of an industry to an actual
 * colour
 */

#define SWITCH_COLOUR_SCHEME1(name) \
switch(FEAT_INDUSTRIES, SELF, name, colour) { \
	0: return 0; \
	1: return 1; \
	2: return 2; \
	3: return 13; \
	4: return 2; \
	5: return 5; \
	6: return 1; \
	7: return 1; \
	8: return 0; \
	9: return 14; \
	10: return 10; \
	11: return 11; \
	12: return 13; \
	13: return 13; \
	14: return 14; \
	15: return 14; \
	return 0; \
}

#define SWITCH_COLOUR_SCHEME2(name) \
switch(FEAT_INDUSTRIES, SELF, name, colour) { \
	0: return 5; \
	1: return 1; \
	2: return 2; \
	3: return 3; \
	4: return 2; \
	5: return 5; \
	6: return 1; \
	7: return 7; \
	8: return 5; \
	9: return 14; \
	10: return 10; \
	11: return 10; \
	12: return 3; \
	13: return 13; \
	14: return 14; \
	15: return 15; \
	return 0; \
}

/*
 * Check for production last month and increase 'no production counter'
 * if nothing was produced or reset, if something was produced
 */
#define SET_PRODUCTION_COUNTER_PRODUCED(name) \
switch(FEAT_INDUSTRIES, SELF, name ## _increase_no_production, STORE_PERM((1 + LOAD_PERM(store_closure_counter)), store_closure_counter)) { \
	return 0; \
} \
switch(FEAT_INDUSTRIES, SELF, name ## _reset_no_production, [STORE_PERM(0, store_closure_counter), 1]) { \
	return 0; \
} \
switch(FEAT_INDUSTRIES, SELF, name, produced_last_month_1) { \
	0: name ## _increase_no_production; \
	name ## _reset_no_production; \
}

/*
 * Check for a minimum distance to another industry type
 * 
 * switch name:  THIS_ID(param1)
 *               industyname ## incompatible_industryname
 *
 * Parameters:
 * incompatible: name of conflicting industry
 * distance:     minimum required separation
 * retval:       return value: text for error message or "return CB_RESULT_IND_DISALLOW_UNSUITABLE"
 * next:         name of next switch or "return CB_RESULT_IND_ALLOW_LOCATION"
 */

#define CHECK_INCOMPATIBLE(incompatible, distance, text, next) \
switch (FEAT_INDUSTRIES, SELF, THIS_ID(incompatible), industry_distance(incompatible)) { \
	0 .. distance: return text; \
	next; \
}


/*
 * Check whether an industry is within a certain distance from a town centre
 *
 * This switch should be called directly from the callback as THIS_ID(check_location)
 *
 * Usage:        CHECK_TOWN_DISTANCE(switchname, min_distance, max_distance, next)
 *
 * Parameters:
 * switchname:   name of this switch. Suggested: town_distance
 * next          name of next switch or "return CB_RESULT_IND_ALLOW_LOCATION"
 * mindistance   minimum distance to town centre
 * maxdistance   maximum distance to town centre
 */

/* founder == FOUNDER_GAME means founded by the game, 0 .. 15 are player companies */
#define CHECK_TOWN_DISTANCE(name, mindistance, maxdistance, next) \
switch (FEAT_INDUSTRIES, SELF, THIS_ID(name), town_euclidean_dist(0, 0)) { \
	mindistance .. maxdistance: return CB_RESULT_IND_ALLOW_LOCATION; \
	next; \
}

/*
 * Check whether a certain location is suitable for building the industry
 * Restrictions apply only to industries funded by the game.
 *
 * This switch should be called directly from the callback as THIS_ID(check_location)
 *
 * switch name:  THIS_ID(check_location)
 *
 * Parameters:
 * next          name of next switch or "return CB_RESULT_IND_ALLOW_LOCATION"
 */

/* founder == FOUNDER_GAME means founded by the game, 0 .. 15 are player companies */
#define CHECK_FOUNDER(next) \
switch (FEAT_INDUSTRIES, SELF, THIS_ID(check_location), (game_mode == GAMEMODE_GAME) && (founder != FOUNDER_GAME)) { \
	1: return CB_RESULT_IND_ALLOW_LOCATION; \
	next; \
}
