<!--!
    Location checks are defined as macros, to use these load the template as an object and call the macro from the macros dict
    e.g. foo.macros[macro_name] where foo has been loaded in a python script or in a chameleon template
-->

<!--! Loop to render the location checks tree -->

<metal:render_tree metal:define-macro="render_tree">
    #include "../src/templates/tile_location.pnml"
    <tal:tile_location_checks repeat="tile industry.tiles">
        <tal:tile define="location_checks tile.location_checks.get_render_tree(tile.id, industry.id)" repeat="location_check location_checks">
            <tal:legacy condition="location_check.legacy">
                ${location_check.render()}
            </tal:legacy>
            <tal:not_legacy condition="not:location_check.legacy">
                <tal:location_check_macro metal:use-macro="location_check.macro" />
            </tal:not_legacy>
        </tal:tile>
    </tal:tile_location_checks>
</metal:render_tree>


<!--! Location check macros -->

<metal:require_sea_tile metal:define-macro="require_sea_tile">
    <!--! Check that the tile has water class sea (or none, for reasons that aren't clear tbh) -->
    <!--! why is NONE an acceptable water class result for this check?  Related to coast tile checks? -->
    switch(FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point}, nearby_tile_water_class(0,0)) {
        WATER_CLASS_SEA: ${location_check.switch_result};
        WATER_CLASS_NONE: ${location_check.switch_result};
        return CB_RESULT_LOCATION_DISALLOW;
    }
</metal:require_sea_tile>

<!--!
/*
 * Check that the tile for being in a certain height range
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

/* uses more efficient code for (nearby_tile_height(0,0) <= maxh) && (nearby_tile_height(0,0) >= minh) */
#define TILE_CHECK_HEIGHT(name, minh, maxh, inrange, outrange)
switch(FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point}, UCMP(nearby_tile_height(0, 0) - minh, maxh - minh)) {
	0..1: inrange;
	outrange;
}


/*
 * Check that the tile for being a water tile
 */

#define TILE_CHECK_WATER(name, water, land)
switch(FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point}, nearby_tile_is_water(0, 0)) {
	1: water;
	land;
}

/*
 * Check that the tile itself is not a coast or water tile
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

#define TILE_DISALLOW_COAST(name, errtext, next)
switch(FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point}, nearby_tile_is_water(0, 0)) {
	1: return errtext;
	next;
}

/*
 * Check for all nearby tiles and the tile itself NOT being of a specific terrain type
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

#define TILE_DISALLOW_TERRAIN(name, terraintype, errtext, next)
switch(FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point},
			(nearby_tile_terrain_type( 1, -1) == terraintype) &&
			(nearby_tile_terrain_type( 1,  0) == terraintype) &&
			(nearby_tile_terrain_type( 1,  1) == terraintype) &&
			(nearby_tile_terrain_type( 0, -1) == terraintype) &&
			(nearby_tile_terrain_type( 0,  0) == terraintype) &&
			(nearby_tile_terrain_type( 0,  1) == terraintype) &&
			(nearby_tile_terrain_type(-1, -1) == terraintype) &&
			(nearby_tile_terrain_type(-1,  0) == terraintype) &&
			(nearby_tile_terrain_type(-1,  1) == terraintype)
		) {
	1: return errtext;
	next;
}

/*
 * Check for the nearby tiles NOT being of a specific class
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

#define TILE_DISALLOW_NEARBY_CLASS(name, class, errtext, next)
switch(FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point},
    (nearby_tile_class( 1,  1) == class) |
    (nearby_tile_class( 1,  0) == class) |
    (nearby_tile_class( 1, -1) == class) |
    (nearby_tile_class( 0, -1) == class) |
    (nearby_tile_class(-1, -1) == class) |
    (nearby_tile_class(-1,  0) == class) |
    (nearby_tile_class(-1,  1) == class) |
    (nearby_tile_class( 0,  1) == class)) {
    1: return errtext;
    next;
}

/*
 * Check whether a certain location is suitable for building the industry
 * Restrictions apply only to industries funded by the game.
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

/* founder == FOUNDER_GAME means founded by the game, 0 .. 15 are player companies */
#define TILE_ALLOW_PLAYER(name, next)
switch (FEAT_INDUSTRYTILES, PARENT, ${location_check.switch_entry_point}, (
			(((extra_callback_info2 & 0xFF00) >> 8) == IND_CREATION_FUND) ||
			(((extra_callback_info2 & 0xFF00) >> 8) == IND_CREATION_PROSPECT)
			)
		) {
	1: return CB_RESULT_LOCATION_ALLOW;
	next;
}

/*
 * Check that the tile itself is a flat tile
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

#define TILE_CHECK_FLAT(name, flat, sloped)
switch(FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point}, nearby_tile_slope(0,0) == SLOPE_FLAT) {
	1: flat;
	sloped;
}

/*
 * Check whether a tile is steep slope and only disallow construction in that case
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

#define TILE_DISALLOW_STEEP_SLOPE(name, errtext, next)
switch (FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point}, nearby_tile_slope(0,0) & bitmask(IS_STEEP_SLOPE)) {
	0: next;
	return errtext;
}

/*
 * Check whether a tile is a flat tile and only allow construction in that case
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

#define TILE_DISALLOW_SLOPES(name, errtext, next)
switch (FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point}, nearby_tile_slope(0,0) == SLOPE_FLAT) {
	1: next;
	return errtext;
}


/*
 * Check whether highest corner of a tile is same as highest corner of industry north tile
 *
 * switch name:  ${location_check.switch_entry_point}
 *               tilename ## name
 */

/* The check looks really complex, but is simple:
 * - get the tile height of n tile (lowest corner), add 0, 1, or 2 depending on slope (flat, slope, steep slope)
 * - do same for current tile
 * - if the results match, allow building
 * The stacked ternary operators make it look more complicated than it is.
 */
#define TILE_REQUIRE_EFFECTIVELY_FLAT(name, errtext, next)
switch (FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point},
                                                  (
                                                  nearby_tile_height(-relative_x, -relative_y)
                                                  + (nearby_tile_slope(-relative_x, -relative_y)
                                                  == SLOPE_FLAT ? 0 :
                                                  nearby_tile_slope(-relative_x, -relative_y) == bitmask(IS_STEEP_SLOPE) ? 2 : 1
                                                  )) == (nearby_tile_height(0, 0)
                                                  + (nearby_tile_slope(0, 0)
                                                  == SLOPE_FLAT ? 0 :
                                                  nearby_tile_slope(0, 0) == bitmask(IS_STEEP_SLOPE) ? 2 : 1))
                                                  ) {
	1: next;
	return errtext;
}



/*
 * Check whether an industry *tile* is within a certain distance of houses
 * *
 * Usage:        CHECK_HOUSES_NEARBY(switchname, x, y next)
 */

#define CHECK_HOUSES_NEARBY(name, x, y, next)
switch (FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point}, nearby_tile_class(x, y)) {
    TILE_CLASS_HOUSE: return CB_RESULT_LOCATION_ALLOW;
    next;
}

/*
 * Check whether an industry *tile* is within a certain distance of road
 * *
 * Usage:        CHECK_ROAD_ADJACENT(switchname, next)
 */

#define CHECK_ROAD_ADJACENT(name, next)
switch (FEAT_INDUSTRYTILES, SELF, ${location_check.switch_entry_point},
                                                  (
                                                  nearby_tile_class(0, -1) == TILE_CLASS_ROAD ? 1 :
                                                  (nearby_tile_class(0, 1) == TILE_CLASS_ROAD ? 1 :
                                                  (nearby_tile_class(-1, 0) == TILE_CLASS_ROAD ? 1 :
                                                  (nearby_tile_class(1, 0) == TILE_CLASS_ROAD ? 1 : 0
                                                  ))))) {
    1: next;
    return CB_RESULT_LOCATION_DISALLOW;
}

-->