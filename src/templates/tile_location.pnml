/*
 * Check that the tile for being in a certain height range
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

/* uses more efficient code for (nearby_tile_height(0,0) <= maxh) && (nearby_tile_height(0,0) >= minh) */
#define TILE_CHECK_HEIGHT(name, minh, maxh, inrange, outrange) \
switch(FEAT_INDUSTRYTILES, SELF, THIS_ID(name), UCMP(nearby_tile_height(0, 0) - minh, maxh - minh)) { \
	0..1: inrange; \
	outrange; \
}

/*
 * Check that the tile for having a specific water class
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

#define TILE_REQUIRE_SEA(name, next) \
switch(FEAT_INDUSTRYTILES, SELF, THIS_ID(name), nearby_tile_water_class(0,0)) { \
	WATER_CLASS_SEA: next; \
	WATER_CLASS_NONE: next; \
	return CB_RESULT_LOCATION_DISALLOW; \
}

/*
 * Check that the tile for being a water tile
 */

#define TILE_CHECK_WATER(name, water, land) \
switch(FEAT_INDUSTRYTILES, SELF, THIS_ID(name), nearby_tile_is_water(0, 0)) { \
	1: water; \
	land; \
}

/*
 * Check that the tile itself is not a coast or water tile
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

#define TILE_DISALLOW_COAST(name, errtext, next) \
switch(FEAT_INDUSTRYTILES, SELF, THIS_ID(name), nearby_tile_is_water(0, 0)) { \
	1: return errtext; \
	next; \
}

/*
 * Check for all nearby tiles and the tile itself NOT being of a specific terrain type
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

#define TILE_DISALLOW_TERRAIN(name, terraintype, errtext, next) \
switch(FEAT_INDUSTRYTILES, SELF, THIS_ID(name), \
			(nearby_tile_terrain_type( 1, -1) == terraintype) && \
			(nearby_tile_terrain_type( 1,  0) == terraintype) && \
			(nearby_tile_terrain_type( 1,  1) == terraintype) && \
			(nearby_tile_terrain_type( 0, -1) == terraintype) && \
			(nearby_tile_terrain_type( 0,  0) == terraintype) && \
			(nearby_tile_terrain_type( 0,  1) == terraintype) && \
			(nearby_tile_terrain_type(-1, -1) == terraintype) && \
			(nearby_tile_terrain_type(-1,  0) == terraintype) && \
			(nearby_tile_terrain_type(-1,  1) == terraintype) \
		) { \
	1: return errtext; \
	next; \
}

/*
 * Check for the nearby tiles NOT being of a specific class
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

#define TILE_DISALLOW_NEARBY_CLASS(name, class, errtext, next) \
switch(FEAT_INDUSTRYTILES, SELF, THIS_ID(name), \
    (nearby_tile_class( 1,  1) == class) | \
    (nearby_tile_class( 1,  0) == class) | \
    (nearby_tile_class( 1, -1) == class) | \
    (nearby_tile_class( 0, -1) == class) | \
    (nearby_tile_class(-1, -1) == class) | \
    (nearby_tile_class(-1,  0) == class) | \
    (nearby_tile_class(-1,  1) == class) | \
    (nearby_tile_class( 0,  1) == class)) { \
    1: return errtext; \
    next; \
}

/*
 * Check whether a certain location is suitable for building the industry
 * Restrictions apply only to industries funded by the game.
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

/* founder == FOUNDER_GAME means founded by the game, 0 .. 15 are player companies */
#define TILE_ALLOW_PLAYER(name, next) \
switch (FEAT_INDUSTRYTILES, PARENT, THIS_ID(name), ( \
			(((extra_callback_info2 & 0xFF00) >> 8) == IND_CREATION_FUND) || \
			(((extra_callback_info2 & 0xFF00) >> 8) == IND_CREATION_PROSPECT) \
			) \
		) { \
	1: return CB_RESULT_LOCATION_ALLOW; \
	next; \
}

/*
 * Check that the tile itself is a flat tile
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

#define TILE_CHECK_FLAT(name, flat, sloped) \
switch(FEAT_INDUSTRYTILES, SELF, THIS_ID(name), nearby_tile_slope(0,0) == SLOPE_FLAT) { \
	1: flat; \
	sloped; \
}

/*
 * Check whether a tile is steep slope and only disallow construction in that case
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

#define TILE_DISALLOW_STEEP_SLOPE(name, errtext, next) \
switch (FEAT_INDUSTRYTILES, SELF, THIS_ID(name), nearby_tile_slope(0,0) & bitmask(IS_STEEP_SLOPE)) { \
	0: next; \
	return errtext; \
}

/*
 * Check whether a tile is a flat tile and only allow construction in that case
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

#define TILE_DISALLOW_SLOPES(name, errtext, next) \
switch (FEAT_INDUSTRYTILES, SELF, THIS_ID(name), nearby_tile_slope(0,0) == SLOPE_FLAT) { \
	1: next; \
	return errtext; \
}


/*
 * Check whether highest corner of a tile is same as highest corner of industry north tile
 *
 * switch name:  THIS_ID(name)
 *               tilename ## name
 */

/* The check looks really complex, but is simple:
 * - get the tile height of n tile (lowest corner), add 0, 1, or 2 depending on slope (flat, slope, steep slope)
 * - do same for current tile
 * - if the results match, allow building
 * The stacked ternary operators make it look more complicated than it is.
 */
#define TILE_REQUIRE_EFFECTIVELY_FLAT(name, errtext, next) \
switch (FEAT_INDUSTRYTILES, SELF, THIS_ID(name),  \
                                                  ( \
                                                  nearby_tile_height(-relative_x, -relative_y) \
                                                  + (nearby_tile_slope(-relative_x, -relative_y) \
                                                  == SLOPE_FLAT ? 0 : \
                                                  nearby_tile_slope(-relative_x, -relative_y) == bitmask(IS_STEEP_SLOPE) ? 2 : 1 \
                                                  )) == (nearby_tile_height(0, 0) \
                                                  + (nearby_tile_slope(0, 0) \
                                                  == SLOPE_FLAT ? 0 : \
                                                  nearby_tile_slope(0, 0) == bitmask(IS_STEEP_SLOPE) ? 2 : 1)) \
                                                  ) { \
	1: next; \
	return errtext; \
}



/*
 * Check whether an industry *tile* is within a certain distance of houses
 * *
 * Usage:        CHECK_HOUSES_NEARBY(switchname, x, y next)
 */

#define CHECK_HOUSES_NEARBY(name, x, y, next) \
switch (FEAT_INDUSTRYTILES, SELF, THIS_ID(name), nearby_tile_class(x, y)) { \
    TILE_CLASS_HOUSE: return CB_RESULT_LOCATION_ALLOW; \
    next; \
}

/*
 * Check whether an industry *tile* is within a certain distance of road
 * *
 * Usage:        CHECK_ROAD_ADJACENT(switchname, next)
 */

#define CHECK_ROAD_ADJACENT(name, next) \
switch (FEAT_INDUSTRYTILES, SELF, THIS_ID(name), \
                                                  ( \
                                                  nearby_tile_class(0, -1) == TILE_CLASS_ROAD ? 1 : \
                                                  (nearby_tile_class(0, 1) == TILE_CLASS_ROAD ? 1 : \
                                                  (nearby_tile_class(-1, 0) == TILE_CLASS_ROAD ? 1 : \
                                                  (nearby_tile_class(1, 0) == TILE_CLASS_ROAD ? 1 : 0 \
                                                  ))))) { \
    1: next; \
    return CB_RESULT_LOCATION_DISALLOW; \
}
